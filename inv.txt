# Uniswap V2 Core Invariants

## Constant Product Formula (x * y = k)
- The fundamental invariant: reserve0 * reserve1 = k (constant)
- After any swap: (reserve0 + amount0In - amount0Out) * (reserve1 + amount1In - amount1Out) >= k
- The K invariant is enforced in the swap function: balance0Adjusted * balance1Adjusted >= reserve0 * reserve1 * 1000^2

## Liquidity Provision Invariants
- Total supply must always be positive: totalSupply > 0
- Minimum liquidity is permanently locked: MINIMUM_LIQUIDITY = 10^3 tokens
- Liquidity minting: liquidity = min(amount0 * totalSupply / reserve0, amount1 * totalSupply / reserve1)
- Liquidity burning: amount0 = liquidity * balance0 / totalSupply, amount1 = liquidity * balance1 / totalSupply

## Reserve Management
- Reserves must match actual token balances: balance0 == reserve0, balance1 == reserve1
- Reserves are updated atomically in _update() function
- Overflow protection: balance0 <= uint112(-1) && balance1 <= uint112(-1)

## Security Invariants
- Lock mechanism prevents reentrancy: unlocked == 1 before and after operations
- Factory ownership: only factory can initialize pairs
- Token ordering: token0 < token1 (deterministic ordering)
- No self-swaps: to != token0 && to != token1

## Fee Mechanism
- Protocol fee: 0.3% fee on swaps (3/1000)
- Fee calculation: balance0Adjusted = balance0 * 1000 - amount0In * 3
- Fee collection: kLast tracks k value for fee calculation
- Fee minting: liquidity = totalSupply * (rootK - rootKLast) / (rootK * 5 + rootKLast)

## Price Oracle Invariants
- Cumulative price tracking: price0CumulativeLast, price1CumulativeLast
- Price calculation: price0 = reserve1 / reserve0, price1 = reserve0 / reserve1
- Time-weighted average price (TWAP) support

## Factory Invariants
- Unique pair addresses: getPair[token0][token1] == getPair[token1][token0]
- Pair creation: only one pair per token combination
- Fee setter authorization: only feeToSetter can change feeTo
